
R version 3.1.1 Patched (2014-07-11 r66127) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "coenocliner"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('coenocliner')
This is coenocliner 0.0-10
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("coenocline")
> ### * coenocline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coenocline
> ### Title: Simulate species abundance (counts) or occurrence along one or
> ###   two gradients
> ### Aliases: coenocline
> ### Keywords: datagen
> 
> ### ** Examples
> 
> ## Poisson counts along a single gradient, Gaussian response
> 
> x <- seq(from = 4, to = 6, length = 100)
> opt <- c(3.75, 4, 4.55, 5, 5.5) + 0.5
> tol <- rep(0.25, 5)
> h <- rep(20, 5)
> 
> ## simulate
> set.seed(1)
> y <- coenocline(x, responseModel = "gaussian",
+                 params = cbind(opt = opt, tol = tol, h = h),
+                 countModel = "poisson")
> head(y)
     [,1] [,2] [,3] [,4] [,5]
[1,]    9    3    0    0    0
[2,]   17    8    0    0    0
[3,]   18    4    0    0    0
[4,]   16    5    0    0    0
[5,]   21    5    0    0    0
[6,]   19    4    0    0    0
> 
> y <- coenocline(x, responseModel = "gaussian",
+                 params = cbind(opt = opt, tol = tol, h = h),
+                 countModel = "poisson",
+                 expectation = TRUE)
> matplot(x, y, type = "l", lty = "solid")
> 
> 
> ## Poisson counts along two correlated gradients, Gaussian response
> set.seed(1)
> x1 <- runif(300, min = 4, max = 6)
> opt1 <- seq(4, 6, length = 5)
> tol1 <- rep(0.25, 5)
> x2 <- runif(300, min = 2, max = 20)
> opt2 <- seq(2, 20, length = 5)
> tol2 <- rep(1, 5)
> h <- rep(20, 5)
> 
> set.seed(1)
> params <- list(px = list(opt = opt1, tol = tol1, h = h),
+                py = list(opt = opt2, tol = tol2))
> y <- coenocline(cbind(x1, x2),
+                 responseModel = "gaussian",
+                 params = params,
+                 extraParams = list(corr = 0.5),
+                 countModel = "poisson")
> head(y)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]    0    0    0    0    0
[3,]    0    0    0    0    0
[4,]    0    0    0    0    0
[5,]    0    0    0    0    0
[6,]    0    0    0    0    0
> 
> ## Recreate Fig. 2 of Minchin (1987)
> A0 <- c(5,4,7,5,9,8) * 10
> m <- c(25,85,10,60,45,60)
> r <- c(3,3,4,4,6,5) * 10
> alpha <- c(0.1,1,2,4,1.5,1)
> gamma <- c(0.1,1,2,4,0.5,4)
> x <- 1:100
> params <- list(m = m, A0 = A0, r = r, alpha = alpha, gamma = gamma)
> 
> ## Expectations
> set.seed(2)
> y <- coenocline(x, responseModel = "beta",
+                 params = params,
+                 countModel = "poisson")
> head(y)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    0    0   40    0    0    0
[2,]    0    0   48    0    5    0
[3,]    0    0   57    0    3    0
[4,]    0    0   57    0    5    0
[5,]    0    0   54    0    8    0
[6,]    0    0   62    0    7    0
> matplot(y, type = "l", lty = "solid")
> 
> y <- coenocline(x, responseModel = "beta",
+                 params = params,
+                 countModel = "poisson", expectation = TRUE)
> matplot(y, type = "l", lty = "solid")
> 
> ## Zero-inflated Poisson, constant gamma
> y <- coenocline(x, responseModel = "beta", params = params,
+                 countModel = "ZIP", countParams = list(gamma = 0))
> matplot(y, type = "l", lty = "solid")
> 
> ## Zero-inflated Negative binomial, constant gamma
> y <- coenocline(x, responseModel = "beta",
+                 params = params,
+                 countModel = "ZINB",
+                 countParams = list(alpha = 0.75, gamma = 0))
> matplot(y, type = "l", lty = "solid")
> 
> ## Binomial counts, constant size (m) of 100
> ## A0 must be in range, (0,1)
> params[["A0"]] <- c(5,4,7,5,9,8) / 10
> y <- coenocline(x, responseModel = "beta",
+                 params = params,
+                 countModel = "binomial",
+                 countParams = list(size = 100))
> matplot(y, type = "l", lty = "solid")
> 
> 
> 
> cleanEx()
> nameEx("expand")
> ### * expand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand
> ### Title: An 'expand.grid'-like function that repeats sets of vectors for
> ###   every value in a reference vector.
> ### Aliases: expand
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # Recreate Fig. 2 of Minchin (1987)
> # Parameters for each of 6 six species
> A0 <- c(5,4,7,5,9,8) * 10
> m <- c(25,85,10,60,45,60)
> r <- c(3,3,4,4,6,5) * 10
> alpha <- c(0.1,1,2,4,1.5,1)
> gamma <- c(0.1,1,2,4,0.5,4)
> # Gradient locations
> x <- 1:100
> 
> # expand parameter set
> pars <- expand(x, m = m, A0 = A0, r = r, alpha = alpha,
+                gamma = gamma)
> head(pars)
     x  m A0  r alpha gamma
[1,] 1 25 50 30   0.1   0.1
[2,] 2 25 50 30   0.1   0.1
[3,] 3 25 50 30   0.1   0.1
[4,] 4 25 50 30   0.1   0.1
[5,] 5 25 50 30   0.1   0.1
[6,] 6 25 50 30   0.1   0.1
> 
> 
> 
> cleanEx()
> nameEx("simJamil")
> ### * simJamil
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simJamil
> ### Title: Simulate species abundance data following Jamil & ter Braak
> ###   (2013)
> ### Aliases: simJamil
> ### Keywords: datagen
> 
> ### ** Examples
> 
> set.seed(42)
> N <- 100   # Number of locations on gradient (samples)
> glen <- 4  # Gradient length
> grad <- sort(runif(N, -glen/2, glen/2)) # sample locations
> M <- 10    # Number of species
> sim <- simJamil(n = N, m = M, x = grad, gl = glen, randx = FALSE,
+                 randm = FALSE, expectation = TRUE)
> ## visualise the response curves
> matplot(grad, sim, type = "l", lty = "solid")
> 
> ## simulate binomial responses from those response curves
> sim <- simJamil(n = N, m = M, x = grad, gl = glen, randx = FALSE,
+                 randm = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("species-response")
> ### * species-response
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: species-response
> ### Title: Species response models for coenocline simulation
> ### Aliases: Beta Gaussian species-response
> ### Keywords: datagen
> 
> ### ** Examples
> 
> # A simple example with a single species
> x <- seq(from = 4, to = 6, length = 100)
> px <- list(opt = 4.5, tol = 0.25, h = 20)
> G <- Gaussian(x, px = px)
> head(G)
[1] 2.706706 3.171116 3.691027 4.268216 4.903540 5.596765
> length(G)
[1] 100
> 
> # A more complex example with 6 species, which needs the parameters
> # repeating for each gradient location:
> 
> # Recreate Fig. 2 of Minchin (1987)
> # Parameters for each of 6 six species
> A0 <- c(5,4,7,5,9,8) * 10
> m <- c(25,85,10,60,45,60)
> r <- c(3,3,4,4,6,5) * 10
> alpha <- c(0.1,1,2,4,1.5,1)
> gamma <- c(0.1,1,2,4,0.5,4)
> # Gradient locations
> x <- 1:100
> 
> # expand parameter set
> pars <- expand(x, m = m, A0 = A0, r = r, alpha = alpha,
+ gamma = gamma)
> head(pars)
     x  m A0  r alpha gamma
[1,] 1 25 50 30   0.1   0.1
[2,] 2 25 50 30   0.1   0.1
[3,] 3 25 50 30   0.1   0.1
[4,] 4 25 50 30   0.1   0.1
[5,] 5 25 50 30   0.1   0.1
[6,] 6 25 50 30   0.1   0.1
> 
> xvec <- pars[, "x"]
> px <- as.list(data.frame(pars[, -1]))
> spprc <- Beta(xvec, px = px)
> matplot(matrix(spprc, ncol = 6), ## 6 species
+         type = "l", lty = "solid")
> 
> # Bivariate beta, single species
> xx <- 1:100
> yy <- 1:100
> xy <- expand.grid(x = xx, y = yy)
> parx <- expand(xy[, "x"], A0 = 50, m = 60, r = 40, alpha = 4, gamma = 4)
> pary <- expand(xy[, "y"], m = 60, r = 40, alpha = 4, gamma = 4)
> 
> x <- parx[,1]
> px <- as.list(as.list(data.frame(parx[, -1])))
> y <- pary[,1]
> py <- as.list(as.list(data.frame(pary[, -1])))
> 
> spprc <- Beta(x, y, px = px, py = py)
> persp(xx, yy, matrix(spprc, ncol = length(xx)))
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.348 0.001 0.35 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
